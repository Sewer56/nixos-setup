// Creates the opencode-instance-{N} directory if running /task_hard or /task_medium commands.
// Don't forget to `npm install` !!

import type { Plugin } from "@opencode-ai/plugin"
import * as fs from 'fs';
import * as path from 'path';

/**
 * Get the next available instance ID by checking existing directories
 */
function getNextInstanceId(baseDir: string): number {
  if (!fs.existsSync(baseDir)) {
    return 1;
  }

  const existingDirs = fs.readdirSync(baseDir)
    .filter(dir => {
      const fullPath = path.join(baseDir, dir);
      return fs.statSync(fullPath).isDirectory() && dir.startsWith('opencode-instance-');
    });

  if (existingDirs.length === 0) {
    return 1;
  }

  const numbers = existingDirs
    .map(dir => {
      const match = dir.match(/opencode-instance-(\d+)/);
      return match ? parseInt(match[1], 10) : 0;
    })
    .filter(num => num > 0);

  return numbers.length > 0 ? Math.max(...numbers) + 1 : 1;
}

/**
 * Create the opencode-instance directory and copy prompt file
 */
function createInstanceDirectory(cwd: string, instanceId: number, promptFilePath: string): { success: boolean; result: string } {
  try {
    const baseDir = path.join(cwd, 'opencode-storage');
    const instanceDir = path.join(baseDir, `opencode-instance-${instanceId}`);

    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true });
    }

    if (!fs.existsSync(instanceDir)) {
      fs.mkdirSync(instanceDir, { recursive: true });
    }

    if (!fs.existsSync(promptFilePath)) {
      return { success: false, result: `Prompt file not found: ${promptFilePath}` };
    }

    if (!fs.statSync(promptFilePath).isFile()) {
      return { success: false, result: `Path is not a file: ${promptFilePath}` };
    }

    const promptContent = fs.readFileSync(promptFilePath, 'utf8');
    const promptDestination = path.join(instanceDir, 'PROMPT.md');

    fs.writeFileSync(promptDestination, promptContent);

    return { success: true, result: instanceDir };
  } catch (error: any) {
    return { success: false, result: `Error: ${error.message}` };
  }
}

/**
 * Check if message contains task command and extract prompt path
 */
function parseTaskCommand(messageContent: string): { isTask: boolean; taskType: string; promptPath: string } {
  const taskHardMatch = messageContent.match(/\/task_hard\s+(\S+)/);
  const taskMediumMatch = messageContent.match(/\/task_medium\s+(\S+)/);

  if (taskHardMatch) {
    return { isTask: true, taskType: 'task_hard', promptPath: taskHardMatch[1] };
  }

  if (taskMediumMatch) {
    return { isTask: true, taskType: 'task_medium', promptPath: taskMediumMatch[1] };
  }

  return { isTask: false, taskType: '', promptPath: '' };
}

/**
 * Extract text content from UserMessage
 */
function extractMessageContent(message: any): string {
  if (typeof message === 'string') {
    return message;
  }

  if (message && typeof message === 'object') {
    // Handle different UserMessage structures
    if ('content' in message && typeof message.content === 'string') {
      return message.content;
    }
    if ('text' in message && typeof message.text === 'string') {
      return message.text;
    }
    // Handle parts array in message
    if ('parts' in message && Array.isArray(message.parts)) {
      return message.parts
        .filter((part: any) => part.type === 'text')
        .map((part: any) => part.text)
        .join('');
    }
  }

  return '';
}

let pluginDirectory: string;

export const TaskWorkflowPlugin: Plugin = async ({ directory }) => {
  pluginDirectory = directory;
  console.log('TaskWorkflowPlugin initialized in directory:', pluginDirectory);

  return {
    "chat.params": async (input, _output) => {
      try {
        console.log('input:', input);

        const messageContent = extractMessageContent(input.message);

        if (!messageContent) {
          return;
        }

        const { isTask, taskType, promptPath } = parseTaskCommand(messageContent);

        if (isTask) {
          console.log(`[TASK WORKFLOW] Detected ${taskType} command with prompt: ${promptPath}`);

          const baseDir = path.join(pluginDirectory, 'opencode-storage');
          const instanceId = getNextInstanceId(baseDir);

          const { success, result } = createInstanceDirectory(pluginDirectory, instanceId, promptPath);

          if (!success) {
            console.error(`[TASK WORKFLOW] Failed to create instance directory: ${result}`);
            return;
          }

          // Append context information directly to the message content
          const contextMessage = `\n\n[TASK WORKFLOW] Directory opencode-instance-${instanceId} created at ${result}. Prompt file copied to ${result}/PROMPT.md. Subagents will create INVESTIGATION_REPORT.md, FLOW_REPORT.md and PLAN.md files in this directory.`;

          // Modify the message content to include our context
          if (typeof input.message === 'string') {
            (input as any).message = messageContent + contextMessage;
          } else if (input.message && typeof input.message === 'object') {
            if ('content' in input.message) {
              (input.message as any).content = messageContent + contextMessage;
            } else if ('text' in input.message) {
              (input.message as any).text = messageContent + contextMessage;
            }
          }

          console.log(`[TASK WORKFLOW] Successfully created instance directory: ${result}`);
        }
      } catch (error: any) {
        console.error('[TASK WORKFLOW] Plugin error:', error.message);
      }
    }
  };
};